C51 COMPILER V9.00   STC_ISR                                                               03/15/2017 16:59:06 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE STC_ISR
OBJECT MODULE PLACED IN STC_ISR.OBJ
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE STC_ISR.C BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          ////**********************************////
   2          //=================//
   3          //本程序适用于
   4          //用于USB485-232 写卡器
   5          //MCU：stc12c5a08s2
   6          //晶振：29.4912MHz 震荡周期0.4069us
   7          //文件：STC_ISR.C
   8          //================//
   9          ////**********************************////
  10          #include<STC_ISR.H>
  11          #include<STC_USER.H>
  12          /*局部变量定义*/
  13          sbit LED1=P1^6;
  14          sbit LED2=P1^7;
  15          sbit LED7=P0^1;
  16          sbit LED8=P0^2;
  17          sbit LED9=P0^3;
  18          
  19          unsigned char receive_PC_count=0;//计数接收来自PC数据  
  20          unsigned char start_receive_pc=0;
  21          volatile unsigned char xdata receive_PC_data[50];//接收来自PC数据  
  22          unsigned char receive_PC_overtime_count=0;//接收PC数据超时计数 
  23          unsigned char receive_cardhead_overtime_count=0;//接收CARDHEAD数据超时计数 
  24          unsigned char t0_count=0;
  25          volatile bit time_200ms_ready=0;
  26          unsigned char receive_cardhead_count=0;//接收卡头数据计数 
  27          volatile bit delay1s_ready=0;
  28          unsigned char delay1s_count=0;    
  29          
  30          /**/
  31          /*全局变量定义*/
  32          volatile unsigned char xdata received_PC_data[48];//来自PC校验成功的数据 出去帧头 帧尾    
  33          volatile bit receive_pc_success=0;//接收PC数据成功标志  
  34          volatile unsigned char xdata receive_CARDHEAD_data[30];//接受来自卡头数据
  35          extern unsigned char receive_cardhead_start;//接收卡头数据状态  
  36          extern unsigned char receive_cardhead_success;//接收卡头数据成功标志 
  37          extern unsigned char xdata received_CARDHEAD_data[28];//接收卡头数据成功  
  38          extern unsigned char receive_card_state;//接收卡数据状态  
  39          extern unsigned char xdata send_pc_data[50];
  40          extern unsigned char send_pc_count;
  41          /**/
  42          
  43          
  44          //*************************//
  45          //name:init_time0
  46          //discription:定时器0中断初始化
  47          //in:
  48          //out:
  49          void TIME0_ISR()interrupt 1 using 1
  50          {
  51   1        TF0=0;
  52   1        TL0=(65535-t_20ms)%256;
  53   1        TH0=(65535-t_20ms)/256;
  54   1        delay1s_count++;
  55   1        if(delay1s_count>=50) delay1s_ready=1;
C51 COMPILER V9.00   STC_ISR                                                               03/15/2017 16:59:06 PAGE 2   

  56   1        t0_count++;
  57   1        if(t0_count>=10)
  58   1        {
  59   2          t0_count=0;
  60   2          time_200ms_ready=1;
  61   2          LED2=!LED2;
  62   2        }
  63   1        if(start_receive_pc)
  64   1        {     
  65   2          receive_PC_overtime_count++;
  66   2          if(receive_PC_overtime_count>=10)
  67   2          {
  68   3            int i=0;
  69   3            start_receive_pc=0;
  70   3            for(i=0;i<48;i++)
  71   3            {
  72   4              received_PC_data[i]=0;
  73   4              receive_pc_success=0;
  74   4            }
  75   3          }
  76   2        }
  77   1        if(receive_card_state==0)
  78   1        {
  79   2          receive_cardhead_overtime_count++;
  80   2          if(receive_cardhead_overtime_count>=4)
  81   2          {
  82   3            int i=0;
  83   3            receive_cardhead_start=0;
  84   3            receive_card_state=0x80;
  85   3            receive_cardhead_overtime_count=0;
  86   3            for(i=0;i<28;i++)
  87   3            {
  88   4              received_CARDHEAD_data[i]=0;
  89   4              receive_cardhead_success=0;
  90   4            }   
  91   3          }
  92   2        }
  93   1      
  94   1      }
  95          
  96          //******//
  97          
  98          //*************************//
  99          //name:USART1_ISR
 100          //discription:
 101          //in:
 102          //out:
 103          void USART1_ISR(void)interrupt 4 using 2
 104          {
 105   1        int i=0;
 106   1        if(RI)
 107   1        {
 108   2          RI=0;
 109   2          receive_PC_count++;
 110   2          receive_PC_overtime_count=0;
 111   2          if((start_receive_pc==0)&&(SBUF==0xbe))
 112   2          {
 113   3            receive_PC_count=0;
 114   3            start_receive_pc=1;
 115   3            receive_pc_success=0;
 116   3            receive_PC_data[receive_PC_count]=SBUF;
 117   3          }else if(receive_PC_count==1)
C51 COMPILER V9.00   STC_ISR                                                               03/15/2017 16:59:06 PAGE 3   

 118   2          {
 119   3            receive_PC_data[receive_PC_count]=SBUF;
 120   3          }else if(receive_PC_count<(receive_PC_data[1]+2))
 121   2          {
 122   3            receive_PC_data[receive_PC_count]=SBUF;
 123   3            if((receive_PC_count==(receive_PC_data[1]+1))&&(receive_PC_data[receive_PC_count]==0xe0))
 124   3            {
 125   4              if(verr_recevie_pc()==1)
 126   4              {LED7=!LED7;
 127   5                for(i=0;i<48;i++)
 128   5                {
 129   6                  received_PC_data[i]=receive_PC_data[i+1];
 130   6                  receive_pc_success=1;
 131   6                }
 132   5              }else
 133   4              {
 134   5                int i=0;
 135   5                for(i=0;i<48;i++)
 136   5                {
 137   6                  received_PC_data[i]=0;
 138   6                  receive_pc_success=0;
 139   6                }         
 140   5              }
 141   4              start_receive_pc=0;
 142   4            }
 143   3          }else
 144   2          {
 145   3            int i=0;
 146   3            start_receive_pc=0;
 147   3            for(i=0;i<20;i++)
 148   3            {
 149   4              received_PC_data[i]=0;
 150   4              receive_pc_success=0;
 151   4            }     
 152   3          }
 153   2          
 154   2          
 155   2        }
 156   1      //  else if(TI)
 157   1      //  {
 158   1      //    TI=0;
 159   1      //    if(send_pc_count<(send_pc_data[1]+2))
 160   1      //      SBUF=send_pc_data[send_pc_count++];
 161   1      //    else REN=1;
 162   1      //  }
 163   1      }
 164          
 165          //******//
 166          //*************************//
 167          //name:USART1_ISR
 168          //discription:
 169          //in:
 170          //out:
 171          void USART2_ISR(void)interrupt 8 using 3
 172          {
 173   1            int i=0;
 174   1            if(S2CON&0x01)
 175   1            {
 176   2              
 177   2              S2CON&=0xfe;
 178   2              receive_cardhead_count++;
 179   2              receive_cardhead_overtime_count=0;
C51 COMPILER V9.00   STC_ISR                                                               03/15/2017 16:59:06 PAGE 4   

 180   2              if((S2BUF==0xaa)&&(receive_cardhead_start==0))
 181   2              {
 182   3                receive_cardhead_start=1;
 183   3                receive_cardhead_count=0;
 184   3                receive_cardhead_success=0;
 185   3                receive_CARDHEAD_data[receive_cardhead_count]=S2BUF;
 186   3              }else if(receive_cardhead_count<3)
 187   2              {
 188   3                receive_CARDHEAD_data[receive_cardhead_count]=S2BUF;
 189   3              }else if(receive_cardhead_count<(receive_CARDHEAD_data[2]+3))
 190   2              {
 191   3                receive_CARDHEAD_data[receive_cardhead_count]=S2BUF;
 192   3                if(receive_cardhead_count==(receive_CARDHEAD_data[2]+2))
 193   3                {
 194   4                  if(verr_recevie_cardhead()==1)
 195   4                  {
 196   5                    LED9=!LED9;
 197   5                    receive_card_state=0x01;
 198   5                    for(i=0;i<28;i++)
 199   5                    {
 200   6                      received_CARDHEAD_data[i]=receive_CARDHEAD_data[i+2];
 201   6                    }
 202   5                    receive_cardhead_success=1;
 203   5                  }else
 204   4                  {
 205   5                    receive_card_state=0x02;
 206   5                    for(i=0;i<28;i++)
 207   5                    {
 208   6                      received_CARDHEAD_data[i]=0;
 209   6                    }
 210   5                    receive_cardhead_success=0;       
 211   5                  }
 212   4                }
 213   3                receive_cardhead_start=0;
 214   3              }else
 215   2              {
 216   3                for(i=0;i<28;i++)
 217   3                {
 218   4                  received_CARDHEAD_data[i]=0;
 219   4                }
 220   3                receive_card_state=0x04;
 221   3                receive_cardhead_start=0;
 222   3                receive_cardhead_success=0; 
 223   3              }
 224   2            }
 225   1      }
 226          
 227          //******//


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    792    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    128    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
